# 整理
## 免费课
### JS中的数据类型
> 基本数据类型和引用数据类型
- 基本数据类型：number boolean string null undefined symbol
- 引用数据类型：function object array regexp date
- 基本数据类型操作的是值，存放到栈内存；引用数据类型操作的是引用地址，存放到堆内存中
> 检测数据类型的方法（4种）
- typeof：可以检测大多数的数据类型，但是不能检测null、array和regexp这些详细的数据类型。通过typeof value检测数据类型返回的结果首先是一个[字符串]，然后再字符串中包含了对应的数据类型。typeof 数组/正则/对象/ 返回的结构都是"object",所以不能用来区分是数组还是正则。[typeof null=》"object" 空对象指针]【注意：两个及两个以上的typeof，最好检测出来的值都是字符串】
- instanceof:检测当前的实例是否属于这个类。在真实的项目中，我们经常使用instanceof检测数组还是正则还是其他的某一个对象数据类型-》如果我们的项目源码采用的是面向对象编程思想开发的（我们创建了类和实例），我们也会经常用instanceof检测某个实例是否属于某个类[A instanceof B，如果A是B的实例，返回true；否则返回false]。 //->instanceof的不足:
    //1)常规的基本数据类型值,不能使用instanceof进行检测
    //->字面量方式:不是严谨的实例,只不过由于JS的松散性导致了可以使用对应类原型上的方法
    //    var num = 3.141592653;
    //    var str = "珠峰培训";
    //    console.log(num instanceof Number);//->false
    //    console.log(str instanceof String);//->false
    //    console.log(typeof num, typeof str);//->"number"、"string"

    //->实例创建的方式:标准的面向对象创建,这样创建出来的才是严谨的实例
    //    var num2 = new Number(3.141592653);
    //    var str2 = new String("珠峰培训");
    //    console.log(num2 instanceof Number);//->true
    //    console.log(str2 instanceof String);//->true
    //    console.log(typeof num2, typeof str2);//->"object"、"object"

    //2)只要这个类在当前实例的原型链上可以找到,那么用instanceof检测出来的结果永远为true
    //[] ->Array.prototype ->Object.prototype
    //    console.log([] instanceof Array);//->true
    //    console.log([] instanceof Object);//->true

    //    function Fn() {
    //
    //    }
    //    Fn.prototype = new Array;
    //    var f = new Fn;
    //    //f是数组的吗?->不是,因为数组需要有索引有length
    //    console.log(f instanceof Array);//->true
- constructor：constructor和instanceof非常相似：但是constructor是可以自己随意修改的，这样的话很容易出现检测出来的结果是不准确的，所以项目中基本上适不使用constructor来检测的
    //    var b = /^$/;
    //    console.log(b.constructor === Array);//->false
    //    console.log(b.constructor === RegExp);//->true
    //    RegExp.prototype.constructor = Object;
    //    console.log(b.constructor === RegExp);//->false
- Object.prototype.toString.call() 返回当前对象所属类的详细信息->"[object Object]":中括号是固定的,第一个object也是固定的,第二个Object代表当前的对象是Object这个类的实例
  //var obj={name:"珠峰"};
    //obj.toString() ->"[object Object]"
    //->深入解析:
    //-->obj.toString===Object.prototype.toString
    //-->obj.toString() !== Object.prototype.toString() 因为第一种执行的时候,toString方法中的this是谁obj;第二种toString中的this是Object.prototype;
    //-->Object.prototype.toString.call(obj) ->我们只需要让Object原型上的toString方法执行,在执行的时候,让里面的this变为一个值,那么返回的结果就是这个值所属类的详细信息
    //    var ary = [];
    //    console.log(Object.prototype.toString.call(ary) === "[object Array]");//->true
    //    console.log(({}).toString.call(ary) === "[object Array]");
### null和undefined
> 都表示没有的意思
- null：空
  1. 给变量初始化一个默认值
  2. 给引用数据类型赋值为空，清除内存
- undefined：未定义
  1. 声明了一个变量没有赋值，则这个变量属于未定义（只声明未定义=》undefined）
  2. 函数中没有返回值，输出函数执行的结果就是undefined
  3. 函数中的参数，在没有赋值的情况下属于undefined
  4. 求一个对象中未知的属性名所对应的属性值，返回undefined
```
    var obj3 = {}
    console.log(obj3.age)//undefined
```
### 比较的规则
  >  = 赋值
  >  == 一般比较：判断两边的值是否相等,返回是true和false
  >  === 严格比较：数据类型和值都相同的情况下才会返回true
  > != 一般比较中的不等于 ;用的是一般比较中的比较方式
  > !== 严格比较中的不相等 ; 用的是严格比较中的比较方式
  1. 两个相同的对象进行比较，属于两个堆内存比较，他们分别在浏览器中属于不同的引用地址，所以一般比较[==]的时候不相等
  ```
   console.log([] == []);//=>false
    console.log(({name:1}) == ({name:1}));
    //  我们将obj1的引用地址赋值给了obj2，此时，obj2拿到的是obj1的引用地址。所以他们一般比较的时候是相等的
    console.log(obj1 == obj2);//=>true
  ```
  2. 同类型进行一般比较：直接比较
  ```
  null == undefined // true
  'a' == 'b' // false
  '1' == '0';// false
  ```
  3. 同类型的引用数据类型=》全部都是false
  ```
  [] == [] // false
  注意带感叹号的，先转布尔值
  ![] == [] // true  !true == '' false == 0  0==0
  ![1] == [1] // false
  ```
  4. 不同数据类型进行比较（均转成布尔值进行比较）

  - 数字和字符串比较先转成 数字
  ```
  1 == '1' // true
  1 == true // true
  1 == undefined // false
  0 == null // false
  ```
  5. 注意 null和 undefined与任何数据类型比较都是false
  ```
  null == undefined // true
  null === undefined // false
  ```
### 函数
 > 函数又叫做方法，函数属于函数数据类型，又属于引用数据类型。
 - 1. 函数分为2部分，一个是定义函数，一个是执行函数，只有执行的时候，这个函数才有意义。
 - 2. 实参和形参是一一对应
 - 3. 函数每次执行都互相之间没有任何关系，都是独立存在的
 ```
    // 函数的定义阶段
    function 函数名 (形参) {
         函数体:代码执行的地方
    }
    // 函数的执行阶段
    函数名(实参)
 ```
 注意：函数中的返回值 return
 - 1. 如果函数执行的时候，没有return，那么函数执行的返回结果就是undefined
 - 2. 如果写了return，但是return后面没有任何值，那么它的返回结果是undefined
 - 3. 如果写了return,return后面也有值,那么它的返回结果就是后面的那个值
 - 4. 如果写了return,return下面的代码全部不执行;
#### 自执行函数
 > 自执行函数 浏览器加载的时候，立刻执行的一个函数
 ```
 (function(){})()
 ```
### 三个循环 
- for 
- for in
- while
### 数组
> 是引用数据类型，操作的是引用地址，有序；数组有索引，有length，索引就是属性名；
> 类数组：1.函数的实参集合（arguments）；2.元素集合（通过dom方法获取到的多个元素）
  注意：类数组没有数组上的属性和方法，不能使用数组上的方法
```
ary.length--
ary[ary.length-1]//把数组的末尾向删除
ary[ary.length]='d'//在原来数组的最后面增加一项
```
#### 数组的常用方法
> 只要是数组数据类型，就可以调用数组上的属性和方法。调用方法就是在执行函数。可以通过__proto__找到数组数据类型上的所有供方法
- push 
    作用：给数组的末尾增加项
    参数：任意多个数据类型
    返回值：增加后的数组长度
    原数组：改变
    ```
    var ary=[1,2]
    var a =ary.push(2,5,'b')
    console.log(a)=>5
    console.log(ary)=>[1, 2, 2, 5, "b"]
    ```
- unshift
    作用：给数组的开头增加项
    参数：任意多个数据类型
    返回值：增加后的数组长度
    原数组：改变
 ```
    var ary=[1,2]
    var a =ary.unshift(2,5,'b')
    console.log(a)=>5
    console.log(ary)=>[2, 5, "b", 1, 2]
    ```
- shift 
    作用：给数组的开头删除一项
    参数：无
    返回值：被删除的那一项
    原数组：改变
    ```
    var ary=[1,2]
    var a =ary.shift()
    console.log(a)=>1
    console.log(ary)=>[2]
    ```
- pop
    作用：给数组的末尾删除一项
    参数：无
    返回值：被删除的那一项
    原数组：改变
    ```
    var ary=[1,2]
    var a =ary.pop()
    console.log(a)=>2
    console.log(ary)=>[1]
    ```