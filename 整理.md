# 整理
## 免费课
### JS中的数据类型
> 基本数据类型和引用数据类型
- 基本数据类型：number boolean string null undefined symbol
- 引用数据类型：function object array regexp date
- 基本数据类型操作的是值，存放到栈内存；引用数据类型操作的是引用地址，存放到堆内存中
> 检测数据类型的方法（4种）
- typeof：可以检测大多数的数据类型，但是不能检测null、array和regexp这些详细的数据类型。通过typeof value检测数据类型返回的结果首先是一个[字符串]，然后再字符串中包含了对应的数据类型。typeof 数组/正则/对象/ 返回的结构都是"object",所以不能用来区分是数组还是正则。[typeof null=》"object" 空对象指针]【注意：两个及两个以上的typeof，最好检测出来的值都是字符串】
- instanceof:检测当前的实例是否属于这个类。在真实的项目中，我们经常使用instanceof检测数组还是正则还是其他的某一个对象数据类型-》如果我们的项目源码采用的是面向对象编程思想开发的（我们创建了类和实例），我们也会经常用instanceof检测某个实例是否属于某个类[A instanceof B，如果A是B的实例，返回true；否则返回false]。 //->instanceof的不足:
    //1)常规的基本数据类型值,不能使用instanceof进行检测
    //->字面量方式:不是严谨的实例,只不过由于JS的松散性导致了可以使用对应类原型上的方法
    //    var num = 3.141592653;
    //    var str = "珠峰培训";
    //    console.log(num instanceof Number);//->false
    //    console.log(str instanceof String);//->false
    //    console.log(typeof num, typeof str);//->"number"、"string"

    //->实例创建的方式:标准的面向对象创建,这样创建出来的才是严谨的实例
    //    var num2 = new Number(3.141592653);
    //    var str2 = new String("珠峰培训");
    //    console.log(num2 instanceof Number);//->true
    //    console.log(str2 instanceof String);//->true
    //    console.log(typeof num2, typeof str2);//->"object"、"object"

    //2)只要这个类在当前实例的原型链上可以找到,那么用instanceof检测出来的结果永远为true
    //[] ->Array.prototype ->Object.prototype
    //    console.log([] instanceof Array);//->true
    //    console.log([] instanceof Object);//->true

    //    function Fn() {
    //
    //    }
    //    Fn.prototype = new Array;
    //    var f = new Fn;
    //    //f是数组的吗?->不是,因为数组需要有索引有length
    //    console.log(f instanceof Array);//->true
- constructor：constructor和instanceof非常相似：但是constructor是可以自己随意修改的，这样的话很容易出现检测出来的结果是不准确的，所以项目中基本上适不使用constructor来检测的
    //    var b = /^$/;
    //    console.log(b.constructor === Array);//->false
    //    console.log(b.constructor === RegExp);//->true
    //    RegExp.prototype.constructor = Object;
    //    console.log(b.constructor === RegExp);//->false
- Object.prototype.toString.call() 返回当前对象所属类的详细信息->"[object Object]":中括号是固定的,第一个object也是固定的,第二个Object代表当前的对象是Object这个类的实例
  //var obj={name:"珠峰"};
    //obj.toString() ->"[object Object]"
    //->深入解析:
    //-->obj.toString===Object.prototype.toString
    //-->obj.toString() !== Object.prototype.toString() 因为第一种执行的时候,toString方法中的this是谁obj;第二种toString中的this是Object.prototype;
    //-->Object.prototype.toString.call(obj) ->我们只需要让Object原型上的toString方法执行,在执行的时候,让里面的this变为一个值,那么返回的结果就是这个值所属类的详细信息
    //    var ary = [];
    //    console.log(Object.prototype.toString.call(ary) === "[object Array]");//->true
    //    console.log(({}).toString.call(ary) === "[object Array]");
### null和undefined
> 都表示没有的意思
- null：空
  1. 给变量初始化一个默认值
  2. 给引用数据类型赋值为空，青春内存
- undefined：未定义
  1. 声明了一个变量没有赋值，则这个变量属于未定义（只声明未定义=》undefined）
  2. 函数中没有返回值，输出函数执行的结果就是undefined
  3. 函数中的参数，在没有赋值的情况下属于undefined
  4. 求一个对象中未知的属性名所对应的属性值，返回undefined
```
    var obj3 = {}
    console.log(obj3.age)//undefined
```
### 比较的规则
  >  = 赋值
  >  == 一般比较
  >  === 严格比较：数据类型和值都相同的情况下才会返回true
  1. 两个相同的对象进行比较，属于两个堆内存比较，他们分别在浏览器中属于不同的引用地址，所以一般比较[==]的时候不相等
  ```
   console.log([] == []);//=>false
    console.log(({name:1}) == ({name:1}));
    //  我们将obj1的引用地址赋值给了obj2，此时，obj2拿到的是obj1的引用地址。所以他们一般比较的时候是相等的
    console.log(obj1 == obj2);//=>true
  ```
### 函数
