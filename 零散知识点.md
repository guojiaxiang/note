*****
## QQ音乐案例
 1、H5中Audio/Video（音频/视频）支持的音乐播放格式
   MP3/MP4(常用) OGG（苹果手机录的音频格式） WAV/WMV
 2、M3U8:直播流（音频）
 3、audio video常用属性
    controls：设置这个属性，则是浏览器默认的播放器控制 （项目中很少使用默认播放器，一般都是自己做）
    autoplay：自动播放
    loop：循环播放
    preload：资源预加载模式（none 开始的时候什么都不加载，播放的时候才开始加载【常用】；metadata 开始加载一些基础信息；auto加载页面就开始加载资源） 
    poster（video独有属性）设置视频未加载时的封面
 4、可以使用filter：blur（）来设置图片的模糊度
 5、box-shadow：inset可以设置盒子的内阴影 
 6、svg格式的图片是代码图片，这种格式的图片加载会更快，消耗的性能更低
 7、infinite 无限多次运动 linear匀速
 8、less中可以用unit((.8-.04)/2)代表所需数值
 9、active 在css中可以表示对应按钮触发时的状态
    darken(颜色，10%)表示颜色加深10%
    lighten(颜色，10%)表示颜色减轻10%
 10、雪碧图的背景图大小就是图片的真实大小background-size=》背景图的原始尺寸
## Vue
 1、filter过滤 不 会操作原数组；返回结果是：过滤后的新数组；回调函数的返回结果：如果返回true，则表示将这一项放到新数组中（可以用来删除不符合条件的项）
 2、map映射 将原有的数组映射成新数组；不会操作原数组 返回结果是一个新数组 回调函数中返回什么这一项就是什么（更新成符合要求的格式）
 3、includes用来判断【数组】中是否包含某一项
 4、find 返回找的那一项，不会改变数组，回调函数中返回true表示找到了，找到后停止循环（可以用来找具体的某一项），找不到返回的是undefined
 5、some找true 找到true后停止，返回true,找不到时返回false
 6、every找false 找到false后停止，返回false，
 7、reduce 收敛 有4个参数 返回的是叠加后的结果，原数组不发生变化，回调函数返回的结果
    第一次：prev代表的是数组的第一项，next是数组的第二项；
    第二次：第一次的返回值回作为第二次的prev值
```
    [[1,2,3],[4,5,6],[7,8,9]]=>[1,2,3,4,5,6,7,8,9]
    let flat=[[1,2,3],[4,5,6],[7,8,9]].reduce(function(prev,next){
      return prev.concat(next)
    });
    console.log(flat)=>[1,2,3,4,5,6,7,8,9]
```
## 面向对象：类的继承封装和多态
  [封装] 把实现一个功能的js代码进行封装，主要目的：‘低耦合高内聚’
  [多态] 
       重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言中的重载），JS中不存在重载的
       重写：子类重写父类的方法
  [继承]
       子类继承父类的属性和方法
       1、原型继承
       2、call继承
       3、寄生组合继承（es5常用）
       4、ES6中class类实现继承（常用）
       ...
```
<!-- 原型继承：让子类的原型指向父类的一个实例 -->
function A(){
  this.x=100;
}
A.prototype={
  constructor:A,
  getX:function (){
    console.log(this.x);
  }
};
function B(){
  this.y=200;
}
B.prototype=new A();
let f=new B()
```
## 写出你所熟悉的ES6新语法说出和ES5的区别
 ES6新语法（让程序更加严谨，更加方便编程）
 - let/const
 > 和es5中var的区别
 > let不存在变量提升机制（变量不允许在声明之前使用）
 > let不允许重复声明
 > 在全局作用域中基于let声明的变量不是window的一个属性，和window没有关系
 > typeof 未被声明的变量=》不是undefined而是报错（暂时性死区）
 > let会形成块级作用域（类似于私有作用域，大部分大括号都会形成块级作用域）
 - 解构赋值
 - “...”拓展、剩余、展开运算符
 - 箭头函数
 > 和普通函数的区别
 > 没有arguments，但是可以基于...arg获取实参集合（结果是一个数组）
 > 没有自己的this，箭头函数中的this是上下文中的this
 - Promise（async/await）
 - class（ES6中创建的）
 - interator（for of 循环）
 - Map/Set
 - ...
## 重排（回流） 重绘读写分离的理解
 > 思路：
 > 1. 首先说出什么是重排和重绘
 > 2. 突出他们好性能
 > 3. 突出自己写项目的时候重点注意了这些事情，以及自己的解决方案（说一下解决原理）
 浏览器渲染一个页面的时候按照"先创建DOM树->在加载CSS->生成渲染树 RENDER TREE->把渲染树交给浏览器（GPU）进行绘制"，如果后期我们修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘，但是一旦元素的位置或者大小等发生改变，浏览器就要从DOM树重新计算渲染，这个机制是回流（重排），不论是重排还是重绘都非常消耗性能
 在我以前的项目中，我特意的重视了这个问题，尽量减少操作DOM引发的回流和重绘问题，常用的解决方案：
 1. 需要动态向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加
 2. 读写分离：把统一修改样式都放到一起执行，新版浏览器都有一个自己的检测机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，直到遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘

 当然还有一些其他的办法，这些事最常注意的，我认为减少DOM的回流重绘是非常重要的性能优化手段之一
 ## 谈谈你对面向对象的理解！
 【JS本身就是面向对象编程的】
 JS本身就是基于面向对象（OOP）编程思想开发出来的语言，我们学习JS就是在学习JS中的类和实例，例如：
 数组是Array的实例、对象是Object的实例、函数是Function的实例..这些内置类的原型上有很多公共的属性和方法，这些方法可以被实例调用，我们学习JS就是学习这些方法..
 【面向对象真实项目的应用】
 平时的业务逻辑开发，我没有刻意使用类的方式来做，只有在一些组件或者插件封装的时候才会基于构造函数和原型链使用类和实例完成，例如：我之前封装过一些TAB页卡、轮播图、模态框、表单验证等插件，就是这样处理的（我之前看了一些类库和插件源码，也都是基于面向对象封装的）
 【面向对象中的一些语法特点】
 所谓面向对象就是基于class或者function创建的一个类，执行的时候new执行创建的一个实例，这样实例就可以调取类上提供的方法，想要基于面向对象进行插件封装，必须掌握关于类的继承、封装和多态，封装就是提取公共的方法，JS中没有严格意义的多态，不能进行方法的重写，常用的继承方式有很多，例如：原型继承、call继承、寄生组合继承、es6中的继承等，有些方法会存在一些问题，我项目中后来都是基于class中的extend实现继承的
