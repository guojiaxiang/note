<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //一、let 和const
    /*
     * 共同点：
     * 1.都没有变量提升
     * 2.let和const声明的变量，不可以重复声明
     * 3.let和const声明的变量，不会给全局对象window增加属性
     * 不同点：const
     * 1.const声明的变量必须赋值
     * 2.const声明的变量不可以进行修改【基本数据类型】，【引用数据类型中的引用地址不可以修改，但是可以修改其中的值】
     *
     * 注意：let声明的变量会先进行全局检查，只要发现相同的变量名直接报错
     * */

    var fn = function () {

    }
    fn();
    // var a;
    //let a;
    // console.log(a);
    // const a;
    //console.log('a' in window);
    var a = 1;
    console.log(window.a);
    //let a;
    //const声明的变量为静态变量，又称为常亮
    //一般情况下我们用const生命的常量都是字符串，而且大多是大写


    /*
     * 二、模板字符串
     * es6 模板字符串 ``
     *  ${}：既可以添加变量，也可以添加三元运算符
     *
     *
     *
     *
     *
     * */
    let name = 'zhufeng';
    let age = 9;
    let code = '学习';
    //我来自zhufeng，我今年九岁，我热爱’学习‘
    let str1 = '我来自' + name + ',我今年' + age + '岁了，我热爱“' + code + '”。';
    let str2 = `我来自${name},我今年${age}岁了，我热爱'${code}'。`;
    //let str3=`<li class="${i==0?'selected':''}"></li>`;
    let str4 = `<li class="${fn()}"></li>`;
    console.log(str4);
    function fn() {
        console.log(1);
        return 'selected'
    }


    /*
     * 三、块级作用域
     * es6推出了块级作用域，它就是一对大括号，但是不包括对象
     * 常用的块级作用域：if else、for、while、switch case、for in、try catch和普通大括号
     *
     *块级作用域中声明的变量如果有变量提升，那么在外面可以拿到；如果没有变量提升，那么外界拿不到
     *
     *
     * */
    console.log(p);
    {
        //var p=1;
        //let p=1;//块级作用域中定义的let，下面的代码拿不到[块级作用域和let声明的变量结合紧密]
        function p() {
        }//function关键字声明的变量会进行提前声明，
        // 【因为有了块级作用域的存在，由原来的声明+定义，变成了只声明】
        // 定义：【第一时间进入块级作用域后进行函数的定义】
        //let p = () => {
        //  console.log(1);};//和用let声明的变量道理是相同的,【看是是谁声明的】
        var a = () => {//用var声明的箭头函数，和块级作用域结合不紧密
            console.log(1);
        }
    }
    console.log(p());
    /*for (var i=0;i<5;i++){
     console.log(i);
     }
     console.log(i);*/
    for (var i = 0; i < 5; i++) {
        setTimeout(() => {
            console.log(i)
        })
        ;
    }
    console.log(i);
    /*for (let j = 0; j < 5; j++) {
     console.log(j);
     }
     console.log(j);*///签名的let j相当于在会计作用域中
    /*for (let j = 0; j < 5; j++) {
     setTimeout(()=>{
     console.log(j)
     });
     }
     console.log(j)*/
    ;//同步代码报错之后，异步代码继续执行
    for (let j = 0; j < 5; j++) {
        let j = 5;
        console.log(j)//5个5
    }//相当于有两个块级作用域，分别在两个块级作用域中用let声明时，不会报错


    /*
     * 四、方法
     * ie低版本都不支持
     *
     * */
    //返回值时布尔值
    let str = 'abcd';
    console.log(str.includes('b'));
    console.log(str.startsWith('b', 1));
    console.log(str.endsWith('c', -1));
    console.log(str.repeat());//重复的个数，如果是0则表示清空字符串

    //Array.from() ;//将类数组或者数组再次转成数组，可以理解成 类数组->数组，数组->克隆
    console.log(Array.of(1)); //将数值转化成数组，但是Array中传一个值的时候会显示[empty]，
    // 多个值则会正常转化成数组
    console.log(Array(1));
    console.log(Array(1, 2));
    var ary = [1, 2, 3, 4, 5];
    //copyWithin(target,start,end) 从索引start到索引end开始截取【包前不包后】，从索引target的位置开始覆盖
    console.log([2, 3, 4, 5, 6].copyWithin(0, 1, 3));
    //find 便利数组，参数是一个函数，直到函数的返回值条件成立，不再继续便利，把条件成立的返回值直接输出
    /*ary.find(function (item,index,inputs) {
     console.log(item, index, inputs);

     })*/
    var a = ary.find(function (item, index, inputs) {
        //console.log(item, index, inputs);
        return item > 2
    });
    console.log(a);
    //fill(value,start,end) 把目标值从索引start到索引end替换成value  【包前不包后】
    var a = ary.fill('x', 0, 2);
    console.log(a);

    /*
     * 对象的方法
     * */
    //判断两个值是否相等，使用的是严格比较，主要是针对有NaN的情况
    Object.is(NaN, NaN)//true
    //assign{...{name: 'zhufeng'}}:将第二个及以后的参数全部赋值到第一个参数中，
    // 如果第一个参数是空对象的话，相当于克隆一个新对象
    console.log(Object.assign({age: 9}, {name: 'zhufeng'}));
    //Symbol:es6中独一无二的值，是一个基本数据类型
    //Set是一个类似数组的值，它是一个引用数据类型，【不是数组，也不是类数组】是一个新的数据类型，
    // 我们必须通过new Set创建一个实例，
    // Set这个数据类型
    //add向Set中增加一个值 delete删除一个值 has判断是否有值 clear清空
    var newAry = new Set([1, 2, 3]);
    newAry.add('a');
    newAry.delete(2);
    console.log(newAry.has(3));
    //Map,通过new关键字创建一个Map对象
    //set：给Map对象增加键值对，delete删除某个键值对，has判断是否有某个键值对，clear清空，get拿到某个值？？？
    var newObj = new Map();
    newObj.set('name', 'zf');


    /*解构赋值：根据等号两边的数据结构，进行解析并且获取其中的内容

     * 常用的解构赋值一般用操作数组和对象
     *
     * */
    //字符串的解构赋值用的比较少
    let [a1, b2, c3, d4, e5] = 'zhufeng';
    console.log(a1, b2, c3, d4, e5);
    let {length} = 'zhufeng';
    console.log(length);
    //数组的解构赋值
    //var ary=[4,5,6,8];
    var ary = [4, [5, {name: 'zf'}], 8];
    let [, [q, {name: w}],] = ary;
    console.log(q, w);
    var ary1 = [4, 5, 6, 7, 8];
    var [g, ...arg] = ary1;
    console.log(arg);
    //给声明数组的一个默认值,其中bbb=2为ary2的默认值，当ary2中没有字符串'x'的时候，输出的bbb就是2；
    // 有的时候则输出字符串'x'
    var ary2 = [1, 'x'];
    var [aaa, bbb = 2] = ary2;
    console.log(aaa, bbb);
    //对象的解构赋值
    let obj1 = {name: 'zf', age: [1, 2, 3, 8, 9]};
    //let {name:A,age:B}=obj1;
    let {name: A, age: [, , , cc,]} = obj1;
    //console.log(A, B);
    console.log(name, cc);
    let {...C} = obj1;//可以实现对象的克隆
    let D = Object.assign({}, obj1);//也可以实现对象的克隆
    let dd = JSON.parse(JSON.stringify(obj1));//也可以实现对象的深拷贝
    console.log(C);
    console.log(D);
    console.log(dd);
    console.log(D === obj1);//false
    console.log(C === obj1);//false
    //通过等号给对象添加默认值
    //obj1.say='heihei';
    let {say = 'haha'} = obj1;
    console.log(say);
    //通过冒号给对象起一个别名
    let Name = 'china';
    let {Name: yy} = obj1;
    console.log(yy);
    console.log(obj1.Name);
    //函数中的解构赋值,通过函数执行，我们可以设置形参给默认值，或者起一个别名
    function fn1(...arg) {
        //arguments
        console.log(arg);
    }
    fn1(1, 2, 3, 4, 5);

    function fn2(arg) {
        //arguments
        console.log(arg[0]);//索引 0
        console.log(...arg);
    }
    fn2([1, 2, 3, 4, 5]);
    /*
     * promise:承诺  es6中的一个类，它是用来处理js当中的异步代码，我可以称它为Promise设计模式
     * 通过new来执行
     * 本身是同步的，在Promise中我们会穿一个函数，并且让这个函数执行。函数执行的时候有两个参数，
     * 一个是resolve表示成功；另一个是reject表示失败
     *
     * */
    var Aa = new Promise((resolve, reject) => {
        console.log(2);
        // resolve();//表示成功，让resolve执行
        //reject();//表示失败，让reject执行
        if (1 % 2) {//1
            resolve(1000)
        } else {
            reject()
        }
    });
    //返回值Aa表示Promise的一个实例
    console.log(1);
    //Aa.then(fn1,fn2)
    //Promise的原型上有一个then方法，可以供Promise的实例来调用，这个then方法有两个实参分别表示，
    //Promise构造函数中的resolve成功【fn1】和reject失败【fn2】
    Aa.then((res) => {
        console.log(res);//1000
    }, () => {

    })//Promise是专门处理异步代码的
    var Bb = new Promise((resolve, reject) => {
        var Cc = 1;
        setInterval(() => {
            resolve(Cc++)
        })
    })
    //原型上的then方法，参数中的两个参数，触发的条件必须是Promise中的resolve和reject，
    // 这两个形参执行才可以触发
    Bb.then((res) => {
        console.log(res);
    }, () => {
        console.log(2);
    })
    //通过Promise封装ajax
    var ajax = new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'data.json', true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4 && xhr.status == 200) {
                resolve(xhr.responseText)//成功后接受的到的是数据
                //准备的状态有可能成功，也有可能失败。我们只看接收的状态，
                // 如果接收不到，我们就让失败的函数执行，参数为失败的原因
            }
            if (xhr.status != 200) {
                reject(xhr.statusText)//失败后返回原因
            }
        }
        xhr.send()
    });
    //方法一
    /* ajax.then((data)=>{
     console.log(data);
     },(reason)=>{
     console.log(reason);
     })*///或者  catch和then方法中的第二个函数的意思是一样的，catch能够接收更多的报错信息
    //方法二
    /*ajax.then((data)=>{
     console.log(data);
     }).catch((reason)=>{
     console.log(reason);
     })*/
    //方法三 两个及两个以上的then方法，只要第一个then执行，下面的then方法中的函数都会相应的去执行
    //【同步执行】，每次then方法的return返回值就是下一个then方法的形参
    ajax.then((data) => {
        console.log(data);
        return data
    }, (reason) => {
        console.log(reason);
    }).then((ary9) => {
        var newAry1 = JSON.parse(ary9);
        console.log(newAry1);
        return 1
    }).then((num) => {
        console.log(num);
        return num + 100
    }).then((newNum) => {
        console.log(newNum);
    })
    /*ajax.then((data)=>{
     return new Promise((resolve,reject)=>{
     setTimeout(()=>{
     resolve(1)
     })
     })
     }).then((num)=>{
     console.log(num);
     })*/
</script>