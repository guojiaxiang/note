<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * Promise: 承诺；es6中的一个类 ，它是用来处理js当中的异步代码，我们可以称它为Promise设计模式
    * 本身Promise是同步的，在Promise中我们会传一个函数，并且让这个函数执行,函数执行的时候，有两个参数一个resolve成功，reject表示失败
    *
    *
    * */
    var a = new Promise((resolve,reject)=>{
        //console.log(2);
        if(1%2){//1 true
            resolve(1000)// 表示成功，让resolve执行
        }else{
            reject()// 失败让reject执行
        }
    });
    //a.then(fn1,fn2)
    // Promise的原型上有一个then方法，可以供Promise的实例来调用，这个then方法有两个实参分别表示，Promise构造函数当中的resolve成功，和reject失败
    a.then((res)=>{
        //console.log(res);//1000
    },()=>{

    })

    // 返回值a表示Promise的一个实例

    // console.dir(Promise)

    // Promise是专门处理异步代码，
    /*var a = new Promise((resolve,reject)=>{
        setTimeout(()=>{
            let value = Math.round(Math.random()*10)
               if(value%2){
                   reject()
               }else{
                   resolve()
               }

        })
    })*/
    // 原型上的then方法，参数中的两个函数，触发的条件必须是Promise中的resolve和reject，这两个形参执行才可以进行触发
    /*a.then((res)=>{
        console.log(1);
    },()=>{
        console.log(2);
    })*/

    // 异步代码=》 定时器，事件 ，ajax，回调函数

    // 通过Promise来封装一个ajax

    var ajax = new Promise((resolve,reject)=>{
        var xhr = new XMLHttpRequest();
        xhr.open('get','data.json',true);
        xhr.onreadystatechange =function(){
            if(xhr.readyState==4&&xhr.status==200){
                resolve(xhr.responseText) // 成功后接收到是数据
            }
            // 准备的状态有可以能成功也有可能失败，我们只看接收的状态，如果接收不到，我们就让失败函数执行，参数为失败的原因
            if(xhr.status != 200){
                reject(xhr.statusText)// 失败后接收到的原因
            }
        }
        xhr.send()
    })
   /* ajax.then((data)=>{
        console.log(data);
    },(reason)=>{
        console.log(reason);
    })*/
   // catch和then方法中的第二个函数的意思是一样的，catch能够接收更多的报错信息
   /*ajax.then((data)=>{
       console.log(data);
   }).catch((reason)=>{
       console.log(reason);
   })*/
   // 两个及两个以上的then方法，只要第一个then执行，下面的then方法中的函数都会相应的去执行【同步执行】,每次then方法的return返回值就是下一个then方法的形参
   /*ajax.then((data)=>{
       console.log(data);
       return data
   },(reason)=>{
       console.log(reason);
   }).then((ary)=>{
       var newAry = JSON.parse(ary);
       console.log(newAry)
       return 1
   }).then((num)=>{
       console.log(num);
       return num+100
   }).then((newNum)=>{
       console.log(newNum)
   })*/
//实现链式调用需要使用类和实例
    //看到第二步的要求时，我们确定了要用原型模式写这个需求
    /*
    * lazyMan  执行  后边能直接调用链式写法，我们知道让lazyMan的返回结果是个类的实例；
    * 创造了一个Man实例，sleep，eat sleepFirst 都是Man原型上的方法
    * 上边的这个写法，已经能实现同步的两个eat，但是不能实现异步sleep；我们想处理异步，想到用事件池去吧 eat和sleep等函数放到事件池中；让事件池中的函数按顺序执行（上一个事件执行完成，再去执行下一个事件）
    * 我们创造了一个this.ary 去存储这些事件；存储的这些事件怎么执行？
    * 我们有创造一个next函数：next函数执行事件池中的第一个函数；
    * 我们让next函数同步执行时，发现后边的两个eat根本没有放到事件池中：因为同步还没有执行到eat；所以这里 我们用的异步 处理next执行；因为异步有个特点就是，需要所有同步代码执行完毕之后 才会执行异步；
    * 走到现在 我们已经能处理两个eat的执行了；前提 我们要在eat执行完毕时接着调用next函数；
    * 下边还剩下两个异步函数； 一个是sleep 一个是sleepFirst
    * sleep：用一个fn 把setTimeout包到函数里边；把fn放到事件池中；；把fn放到（push）事件池中
    * setTimeout执行时，我们紧接着调用next
    *
    *
    * sleepFirst用一个fn 把setTimeout包到函数里边；把fn放到（unshift）事件池中。setTimeout执行时，我们紧接着调用next
    *
    * */
    function Man(name) {
        this.ary = [];
        let that = this;
        function say(){
            console.log(`HI , this is ${name}`);
            console.log(that.ary);
            that.next();
        }
        this.ary.push(say);
        // this.next();
        setTimeout(()=>{
            this.next();
        },10)
        // 直接执行 会导致 后边的两个函数没有push到ary中；需要我们用异步解决这个问题；异步有个特点就是同步代码执行完成之前 异步代码不会执行
    };
    Man.prototype.next = function(){
        let fn = this.ary.shift();
        fn && fn();// fn 存在； 才 让fn执行
    };
    Man.prototype.sleep = function (n) {
        let that = this;
        function fn(){
            setTimeout(()=>{
                console.log(`Wake Up after ${n} s`);
                that.next();
            },n*1000);
        }
        this.ary.push(fn);
        return this;
    };
    Man.prototype.eat = function (str) {
        let that = this;
        function fn() {
            console.log(`Eat ${str} ~`);
            that.next();
        }
        this.ary.push(fn);
        return this;
    };
    Man.prototype.sleepFirst = function (n) {
        let that = this;
        function fn() {
            setTimeout(()=>{
                console.log(`Wake up after ${n} s`);
                that.next();
            },n*1000)
        }
        this.ary.unshift(fn);
        return this;
    };
    function LazyMan(name) {
        return new Man(name)
    }
    let qqq = LazyMan('Hank').eat('dinner').eat('supper');
//把obj中所有的name属性值 都放到一个数组中
    let obj = {
        a: {
            name: "我是a",
            age: 5,
            b: {
                name: "我是a中的b",
                age: 2,
                c: {
                    name: "我是a中的c",
                    sex: 0,
                    b: {
                        name: "我是a中的d"
                    }
                }
            }
        },
        b: {
            c: {
                d: {
                    name: "我是b中的d",
                    age: 10
                }
            }
        }
    };
    let obj2=JSON.parse(JSON.stringify(obj));//可以实现深拷贝
    let arr=[];
    function getName(obj) {
        //使用递归 需要我们把 边界判断处理好 对于这个需求来说也就是 判断出传进来的参数是不是对象即可
        if(typeof obj!=='object') return;
        for(let k in obj){
            if(k=='name'){
                arr.push(obj[k])
            }else{
                getName(obj[k])
            }
        }
    }

    console.log(arr);
    //ary-->【'我是a','我是b','我是c'】


</script>